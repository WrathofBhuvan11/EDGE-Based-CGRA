## EDGE based TRIPS - CGRA Project
## Introduction
A Coarse-Grained Reconfigurable Array (CGRA) is a versatile hardware architecture designed to accelerate compute-intensive applications by leveraging parallelism. It consists of an array of processing elements (PEs) that can be dynamically or statically reconfigured to perform various computations, offering a balance between the flexibility of software and the performance of dedicated hardware. This project implements a CGRA to explore its potential in high-performance, energy-efficient computing for applications such as future robotics inference, digital signal processing, machine learning, and multimedia processing.

TRIPS is one such architecture sub category. It follows EDGE ISA.

## TRIP Microarchitecture EDGE - Explicit data graph execution
The microarchitecture of this CGRA project is designed to be modular and configurable, enabling flexibility for various computational tasks. EDGE combines many individual instructions into a larger group known as a "hyperblock". Hyperblocks are designed to be able to easily run in parallel. TRIPS is a processor based on the Explicit Data Graph Execution (EDGE) ISA.

## TRIPS Processor Architecture Overview
The TRIPS (Tera-op, Reliable, Intelligently adaptive Processing System) architecture is an experimental microprocessor design developed at the UT at Austin as part of DARPA's Polymorphous Computing Architectures (PCA) program in the early 2000s. It serves as a prototype implementation of the Explicit Data Graph Execution (EDGE) Instruction Set Architecture (ISA), aiming to achieve high levels of instruction-level parallelism (ILP), thread-level parallelism (TLP), and data-level parallelism (DLP) while maintaining energy efficiency and adaptability. TRIPS addresses challenges like growing wire delays, power limits, and diminishing clock scaling in traditional processors (e.g., RISC/CISC).

Morph refers to a polymorphic reconfiguration mode in the TRIPS architecture, allowing the processor to adapt its hardware resources (like frame space and memory tiles) to exploit different types of parallelism efficiently. The three morphs are D-morph (Desktop morph for instruction-level parallelism or ILP, optimized for single-threaded desktop applications with large issue windows and speculation), T-morph (Threaded morph for thread-level parallelism or TLP, partitioning resources for multiple threads to improve utilization on multiprogrammed workloads), and S-morph (Streaming morph for data-level parallelism or DLP, configuring memory as stream register files with loop revitalization for vector/streaming codes).hpcwire.com They are named this way to reflect their primary application domains: "D" for desktop/ILP focus on general-purpose single-thread performance, "T" for threaded/TLP emphasis on concurrent threads, and "S" for streaming/DLP targeting data-parallel loops like media processing, aligning with the goal of bridging processor fragility across workloads as per the polymorphous paper.

## TRIPS intro?
TRIPS is a tiled, grid-based processor designed for polymorphic execution—dynamically adapting to different workloads (e.g., single-threaded ILP-heavy tasks or vectorized DLP for AI/math). It targets tera-op performance (trillions of operations per second) on a single chip, using a distributed microarchitecture to minimize global communication and power consumption.

## What is EDGE ISA?
EDGE (Explicit Data Graph Execution) is the ISA powering TRIPS. It's a hybrid dataflow model:
Programs are compiled into atomic hyperblocks (up to 128 instructions each), forming a data graph where dependencies are explicitly encoded.
Instructions don't use traditional registers for intra-block communication; instead, producers directly target consumers (e.g., "ADD result to instr 126's left operand").
Execution is block-atomic: Fetch/execute/commit as a unit, with dynamic issue (out-of-order within block when operands ready).
Constraints for hardware simplicity (from the paper):
* Max 128 instructions/block.
* Max 32 loads/stores (using 5-bit LSIDs for ordering).
* Max 32 register reads/writes (8 per bank across 4 banks).
* Constant outputs: Fixed number of stores, writes, and 1 branch per block.
### ==========================================================
### RTL files planned - 
```
trips_top.sv (Top: Chip; Instances: trips_core_inst[0:3] (4 cores), mem_tile_inst[0:31] (32 tiles), onchip_mem_network_inst (1))
├── trips_core.sv (Instance: trips_core_inst[0:3]; Count: 4)  // Per core: Grid + tiles
│   ├── g_tile.sv (Instance: g_tile_inst; Count: 1)  // Block ctrl, speculation (8 blocks), morph config
│   │   └── block_controller.sv (Instance: block_ctrl; Count: 1)  // Atomicity, revitalization (S-morph), EXIT_ID
│   ├── r_tile.sv (Instances: r_tile_bank[0:3]; Count: 4)  // Banks; queues R/W[0-31], alignment mod 4
│   ├── e_tile.sv (Instances: e_tile_grid[0:3][0:3]; Count: 16)  // Grid nodes; frames=8
│   │   ├── alu_fp_unit.sv (Instance: alu_fp_inst; Count: 1/node)  // G/I/C ops, %bit extract (hi/mid/lo/bottom)
│   │   └── reservation_station.sv (Instance: res_station; Count: 1/node)  // 3 slots (left/right/p), dataflow fire
│   │       └── predicate_handler.sv (Instance: pred_handler; Count: 1)  // _t/_f check, p slot routing
│   ├── i_tile.sv (Instance: i_tile_inst; Count: 1)  // I-cache; TASL decode
│   │   └── isa_decoder.sv (Instance: isa_dec; Count: 1)  // Classes (G/I/L/S/B/C), predicates, LSID/EXIT_ID, sequence <num>
│   ├── d_tile.sv (Instance: d_tile_inst; Count: 1)  // D-cache; LSID queues (32)
│   │   └── lsid_unit.sv (Instance: lsid_handler; Count: 1)  // Ordering for L/S classes
│   └── switching_network.sv (Instance: operand_net; Count: 1)  // Mesh routers; targets (N/W, 0/1/p slots)
├── mem_tile.sv (Instances: mem_tile_inst[0:31]; Count: 32)  // 32KB each; polymorph (cache/scratchpad/SRF)
└── onchip_mem_network.sv (Instance: mem_net; Count: 1)  // Switched 2D; wide channels for SRF (S-morph)
```
####  1.) trips_top.sv: The trips_top.sv module serves as the top-level chip wrapper in the TRIPS processor implementation, instantiating multiple cores (four in the prototype configuration as described in the polymorphous architecture paper) along with 32 memory tiles and the on-chip networks to form the complete system-on-chip. It manages high-level interconnections, clocking, resets, and external interfaces such as memory controllers, ensuring polymorphic reconfiguration across D, T, and S morphs by propagating configuration signals to subordinate modules. This wrapper facilitates scalability, allowing parameterization for different grid sizes and frame depths while adhering to the block-atomic execution model outlined in all three PDFs.
#### 2.) trips_core.sv: The trips_core.sv module represents a single polymorphous core, encapsulating the 4x4 execution grid, associated tiles (G, R, I, D), and internal networks, with parameters enabling morph-specific adaptations like frame partitioning for TLP or SRF integration for DLP as detailed in the polymorphous paper. It handles intra-core dataflow by routing operands and control signals, supporting up to 128 instruction slots per block through its frame space management. The core's parametric design allows for easy scaling to larger grids (e.g., 8x8), aligning with the TASL manual's configurable rows, columns, and frames.
#### 3.) g_tile.sv: The g_tile.sv module implements global control for block management, including fetching hyperblocks from the I-tile, committing outputs upon constant store/register counts (via header masks from the compiler paper), and handling speculation for up to eight in-flight blocks with EXIT_ID branch resolution as per the TASL specification. It coordinates morph configurations by setting frame allocations and revitalization signals for S-morph loops, ensuring atomicity and precise interrupts at block boundaries. This tile interfaces with the block_controller for termination detection and speculation flush, critical for ILP exploitation in D-morph as simulated in the polymorphous paper.
#### 4.) r_tile.sv: The r_tile.sv module models one of the four register banks, each with 32 registers (total 128 architectural G[0-127]), incorporating read/write queues (R/W[0-31]) and enforcing alignment rules (queue mod 8 == reg mod 4) to prevent banking violations as specified in the TASL manual. It buffers up to 32 reads/writes per block, forwarding values to/from the execution grid while supporting inter-block persistence. The module's design supports polymorphic use, maintaining state across morphs without reconfiguration overhead.
#### 5.) e_tile.sv: The e_tile.sv module defines an individual execution node in the grid, featuring combined ALU/FP units for operations across ISA classes (G/I/C with %bit extraction), reservation stations with three slots (left/right/pred) for dataflow execution and predication (_t/_f), as described in the TASL syntax for targets and suffixes. It includes local routers for operand forwarding (1-cycle hops) and supports frame-based time-multiplexing (8-16 frames/node) for large issue windows or partitioning in T/S morphs. This node's design enables out-of-order firing upon operand readiness, central to EDGE's explicit data graph model in all PDFs.
#### 6.) i_tile.sv: The i_tile.sv module implements the banked instruction cache (6KB total, one bank per row plus one for registers), responsible for fetching and decoding hyperblocks into instr_t structs, parsing TASL classes (G/I/L/S/B/C), predicates, LSIDs/EXIT_IDs, sequence numbers, and %bit ops for constants as outlined in the TASL manual. It maps instructions to the execution grid's reservation stations, handling block headers for store masks and morph-specific fetch behaviors (e.g., loop reuse in S-morph). The module ensures high-bandwidth dispatch, supporting speculation by prefetching multiple blocks.
#### 7.) d_tile.sv: The d_tile.sv module handles the banked L1 data cache (2KB total) and interfaces to NUCA L2 tiles, incorporating LSID queues for ordered loads/stores (up to 32 per block) to maintain sequential semantics without disambiguation hardware, as explained in the compiler paper. It supports polymorphic memory modes, configuring as conventional cache for D/T-morphs or SRF with wide channels/gather-scatter for S-morph, per the polymorphous paper. The tile manages hits/misses (2-cycle L1 hit) and commits stores upon block termination.
#### 8.) switching_network.sv: The switching_network.sv module realizes the lightweight operand routing mesh within the core, with per-node routers enabling 1-cycle hops for dataflow forwarding based on X/Y/Z offsets (targets in instr_t), supporting up to two targets per instruction as seen in TASL examples. It facilitates intra-block communication without global buses, scalable for larger grids (4x4 to 8x8), and remains unchanged across morphs for low reconfiguration overhead. This network's design minimizes wire delays, a key motivation in the polymorphous paper.
#### 9.) onchip_mem_network.sv: The onchip_mem_network.sv module implements the switched 2D interconnection for core-to-memory tile access, providing scalable bandwidth to 32x32KB tiles (1MB L2) configurable as NUCA cache, scratchpad, or SRF with enhanced transfers (block/strided/indirect) for S-morph, as detailed in the polymorphous architecture. It handles address routing and polymorphism signals, ensuring low-latency (no tags in SRF mode) for streaming data. The network supports multiple cores (prototype: 4), balancing loads across tiles.
#### 10.) mem_tile.sv: The mem_tile.sv module defines a 32KB memory tile, polymorphously configurable as L2 cache bank (with tags for D/T-morphs), scratchpad, or stream register file (SRF) with direct access and wide 256-bit channels to adjacent cores for S-morph DLP, per the polymorphous paper's SRF description. It includes state machines for replacement, gather/scatter, and synchronization buffers, interfacing via the on-chip network. Each tile's flexibility enables efficient data locality, reducing off-chip accesses.
#### 11.) reservation_station.sv: The reservation_station.sv module per E-node manages frame entries (8-16), each with three operand slots (left/right/pred) for dataflow matching, firing instructions when ready and handling predication (_t/_f checks), as integrated from TASL syntax and compiler's SSA for constants. It supports revitalization in S-morph (reset without remap, preserving constants) and partitioning for T-morph threads. The station's depth enables large windows (128 slots/core), critical for ILP in D-morph.
#### 12.) alu_fp_unit.sv: The alu_fp_unit.sv module combines integer and floating-point operations for G/I/C classes, including arithmetic (add/teq/fmul), constants (genu/gens/app with %hi/%mid/%lo/%bottom bit extraction for 16-bit chunks from 64-bit values), and no-ops, as exemplified in TASL samples. It processes predicates and slots, outputting to targets via the network. This unit's design supports all morphs without change, focusing on low-latency execution (1-cycle ALU).
#### 13.) isa_decoder.sv: The isa_decoder.sv module in the I-tile parses fetched instructions into instr_t, identifying classes (G/I/L/S/B/C), opcodes, targets (up to 2, with slots 0/1/p), predicates (_t/_f), LSIDs/EXIT_IDs (optional, auto-generated if missing), imms (9/16/20-bit), and %bit ops for C class, aligning with TASL formats. It handles sequence numbers for optional serialization and maps to reservation stations. The decoder ensures compliance with constraints (e.g., one branch/block), facilitating block-atomic decoding.
#### 14.) block_controller.sv: The block_controller.sv module, within G-tile, enforces atomicity by counting constant outputs (stores via header mask, writes, one branch), managing revitalization for S-morph loops (reset res stations, keep constants), and frame allocation for polymorphism (large A-frames for D, per-thread for T), as described in the polymorphous paper. It coordinates speculation (flush on mispredict/mis-exit), EXIT_ID resolution for branches, and interrupt precision at boundaries. This controller is key for morph transitions and performance across ILP/TLP/DLP.

Include files
Include Files (.svh)
These are headers for constants, interfaces, structs (non-synth, used in modules):

#### 1. trips_defines.svh: Constants (e.g., BLOCK_SIZE=128, NUM_BANKS=4, LSID_BITS=5, GRID_SIZE=4).
#### 2. trips_types.svh: Typedefs/structs (e.g., instruction format: opcode, targets; operand struct).
#### 3. trips_interfaces.svh: Interface defs (e.g., for tile-to-tile comm: operand ports, control signals).
#### 4. trips_isa.svh: EDGE ISA encodings (e.g., ADD target syntax, NULL instr, MOV fanout).
#### 5. trips_params.svh: Parameter defaults (e.g., REG_COUNT=128, CACHE_SIZE=2048)
